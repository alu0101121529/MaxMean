\hypertarget{classMultiStart}{}\section{Multi\+Start Class Reference}
\label{classMultiStart}\index{Multi\+Start@{Multi\+Start}}


\hyperlink{classMultiStart}{Multi\+Start} implementation to solve Max Mean.  




{\ttfamily \#include $<$multi\+Start.\+hpp$>$}



Inheritance diagram for Multi\+Start\+:\nopagebreak
\begin{figure}[H]
\begin{center}
\leavevmode
\includegraphics[width=145pt]{classMultiStart__inherit__graph}
\end{center}
\end{figure}


Collaboration diagram for Multi\+Start\+:\nopagebreak
\begin{figure}[H]
\begin{center}
\leavevmode
\includegraphics[width=145pt]{classMultiStart__coll__graph}
\end{center}
\end{figure}
\subsection*{Public Member Functions}
\begin{DoxyCompactItemize}
\item 
\hyperlink{classMultiStart_ae16c330042c4b1dfb87dae8312d07a65}{Multi\+Start} (std\+::string filename, int iter, int noimprov, bool anx)
\begin{DoxyCompactList}\small\item\em Construct a new Multi Start object. \end{DoxyCompactList}\item 
std\+::vector$<$ int $>$ \hyperlink{classMultiStart_a29c5796648ede3e6c7fe8ca8043f8187}{construction\+Phase} (std\+::vector$<$ int $>$ first\+Candidates)
\begin{DoxyCompactList}\small\item\em Function to create a initial solution for the problem. \end{DoxyCompactList}\item 
std\+::vector$<$ int $>$ \hyperlink{classMultiStart_a456dc441b6e7028aa86a0488830f9bc1}{R\+CL} (std\+::vector$<$ int $>$, std\+::vector$<$ int $>$)
\begin{DoxyCompactList}\small\item\em Function to create a R\+CL array based on an initial solution. \end{DoxyCompactList}\item 
std\+::vector$<$ int $>$ \hyperlink{classMultiStart_af27ae5dbba5f924070f103b7bf5987a3}{local\+Search} (std\+::vector$<$ int $>$, std\+::vector$<$ int $>$)
\begin{DoxyCompactList}\small\item\em Function that uses a greedy algorithm to improve the solution. \end{DoxyCompactList}\item 
std\+::pair$<$ int, bool $>$ \hyperlink{classMultiStart_a0ad5ed40a5c4ab964cb27f79343eed98}{get\+Worst\+Md} (std\+::vector$<$ int $>$)
\begin{DoxyCompactList}\small\item\em Return the worst node (worst afinity) in the actual solution. \end{DoxyCompactList}\item 
std\+::vector$<$ int $>$ \hyperlink{classMultiStart_a9d842b1f602c4b8a47bf6d88d483ccae}{execute} ()
\begin{DoxyCompactList}\small\item\em Method that executes the algorithm. \end{DoxyCompactList}\end{DoxyCompactItemize}
\subsection*{Additional Inherited Members}


\subsection{Detailed Description}
\hyperlink{classMultiStart}{Multi\+Start} implementation to solve Max Mean. 

\subsection{Constructor \& Destructor Documentation}
\mbox{\Hypertarget{classMultiStart_ae16c330042c4b1dfb87dae8312d07a65}\label{classMultiStart_ae16c330042c4b1dfb87dae8312d07a65}} 
\index{Multi\+Start@{Multi\+Start}!Multi\+Start@{Multi\+Start}}
\index{Multi\+Start@{Multi\+Start}!Multi\+Start@{Multi\+Start}}
\subsubsection{\texorpdfstring{Multi\+Start()}{MultiStart()}}
{\footnotesize\ttfamily Multi\+Start\+::\+Multi\+Start (\begin{DoxyParamCaption}\item[{std\+::string}]{filename,  }\item[{int}]{iter,  }\item[{int}]{noimprov,  }\item[{bool}]{anx }\end{DoxyParamCaption})\hspace{0.3cm}{\ttfamily [inline]}}



Construct a new Multi Start object. 


\begin{DoxyParams}{Parameters}
{\em filename} & \\
\hline
{\em iter} & \\
\hline
{\em noimprov} & \\
\hline
{\em anx} & \\
\hline
\end{DoxyParams}

\begin{DoxyCode}
37 : \hyperlink{classAlgorithm_a89df1d2c6751f70733f38daa0ee2a13b}{Algorithm}(filename), Iterations(iter), NoImprov(noimprov), anxious(anx) \{\}
\end{DoxyCode}
Here is the call graph for this function\+:\nopagebreak
\begin{figure}[H]
\begin{center}
\leavevmode
\includegraphics[width=350pt]{classMultiStart_ae16c330042c4b1dfb87dae8312d07a65_cgraph}
\end{center}
\end{figure}


\subsection{Member Function Documentation}
\mbox{\Hypertarget{classMultiStart_a29c5796648ede3e6c7fe8ca8043f8187}\label{classMultiStart_a29c5796648ede3e6c7fe8ca8043f8187}} 
\index{Multi\+Start@{Multi\+Start}!construction\+Phase@{construction\+Phase}}
\index{construction\+Phase@{construction\+Phase}!Multi\+Start@{Multi\+Start}}
\subsubsection{\texorpdfstring{construction\+Phase()}{constructionPhase()}}
{\footnotesize\ttfamily std\+::vector$<$ int $>$ Multi\+Start\+::construction\+Phase (\begin{DoxyParamCaption}\item[{std\+::vector$<$ int $>$}]{first\+Candidates }\end{DoxyParamCaption})}



Function to create a initial solution for the problem. 


\begin{DoxyParams}{Parameters}
{\em first\+Candidates} & \\
\hline
\end{DoxyParams}
\begin{DoxyReturn}{Returns}
std\+::vector$<$int$>$ 
\end{DoxyReturn}

\begin{DoxyCode}
4 \{
5   std::vector<int> solution;
6   \textcolor{keywordtype}{int} firstNode = rand() % firstCandidates.size();
7   solution.push\_back(firstCandidates[firstNode]);
8   \textcolor{keywordtype}{int} solutionSize = (rand() % (graph.\hyperlink{classMatriz_a6b18342f8c083baece693ff41185a206}{get\_rows}() - 2)) + 2;
9   \textcolor{keywordflow}{while} (solution.size() < solutionSize)
10   \{
11     \textcolor{keywordtype}{int} randomSelection = rand() % firstCandidates.size();
12     \textcolor{keywordflow}{if} (std::find(solution.begin(), solution.end(), firstCandidates[randomSelection]) == solution.end())
13     \{
14       solution.push\_back(randomSelection);
15     \}
16   \}
17   \textcolor{keywordflow}{return} solution;
18 \}
\end{DoxyCode}
Here is the call graph for this function\+:\nopagebreak
\begin{figure}[H]
\begin{center}
\leavevmode
\includegraphics[width=343pt]{classMultiStart_a29c5796648ede3e6c7fe8ca8043f8187_cgraph}
\end{center}
\end{figure}
Here is the caller graph for this function\+:\nopagebreak
\begin{figure}[H]
\begin{center}
\leavevmode
\includegraphics[width=350pt]{classMultiStart_a29c5796648ede3e6c7fe8ca8043f8187_icgraph}
\end{center}
\end{figure}
\mbox{\Hypertarget{classMultiStart_a9d842b1f602c4b8a47bf6d88d483ccae}\label{classMultiStart_a9d842b1f602c4b8a47bf6d88d483ccae}} 
\index{Multi\+Start@{Multi\+Start}!execute@{execute}}
\index{execute@{execute}!Multi\+Start@{Multi\+Start}}
\subsubsection{\texorpdfstring{execute()}{execute()}}
{\footnotesize\ttfamily std\+::vector$<$ int $>$ Multi\+Start\+::execute (\begin{DoxyParamCaption}{ }\end{DoxyParamCaption})\hspace{0.3cm}{\ttfamily [virtual]}}



Method that executes the algorithm. 

\begin{DoxyReturn}{Returns}
std\+::vector$<$int$>$ 
\end{DoxyReturn}


Implements \hyperlink{classAlgorithm_af6ea9eb9a6dbd41896e3fd7dabac096b}{Algorithm}.


\begin{DoxyCode}
99 \{
100   std::vector<int> firstNodes = graph.\hyperlink{classMatriz_a394b84a5ec13fd2f4d202ab218680afe}{getNodes}();
101   std::vector<int> bestSolution;
102   bestSolution.push\_back(0);
103   \textcolor{keywordtype}{float} bestDistance = graph.\hyperlink{classMatriz_a8df14a27d791f24206dd633b2a685c5b}{getMd}(bestSolution);
104   \textcolor{keywordtype}{int} iterations = 0;
105   \textcolor{keywordtype}{int} noImprovement = 0;
106   \textcolor{keywordflow}{while} (iterations < this->Iterations && noImprovement < this->NoImprov)
107   \{
108     iterations++;
109     std::vector<int> initialSol = \hyperlink{classMultiStart_a29c5796648ede3e6c7fe8ca8043f8187}{constructionPhase}(firstNodes);
110     std::vector<int> localSearchVector = \hyperlink{classMultiStart_af27ae5dbba5f924070f103b7bf5987a3}{localSearch}(initialSol, firstNodes);
111     \textcolor{keywordtype}{float} testMd = graph.\hyperlink{classMatriz_a8df14a27d791f24206dd633b2a685c5b}{getMd}(localSearchVector);
112     \textcolor{keywordflow}{if} (testMd > bestDistance)
113     \{
114       bestSolution = localSearchVector;
115       bestDistance = testMd;
116       noImprovement = 0;
117     \}
118     \textcolor{keywordflow}{else}
119     \{
120       noImprovement++;
121     \}
122   \}
123 
124   \textcolor{keywordflow}{return} bestSolution;
125 \}
\end{DoxyCode}
Here is the call graph for this function\+:\nopagebreak
\begin{figure}[H]
\begin{center}
\leavevmode
\includegraphics[width=350pt]{classMultiStart_a9d842b1f602c4b8a47bf6d88d483ccae_cgraph}
\end{center}
\end{figure}
Here is the caller graph for this function\+:\nopagebreak
\begin{figure}[H]
\begin{center}
\leavevmode
\includegraphics[width=342pt]{classMultiStart_a9d842b1f602c4b8a47bf6d88d483ccae_icgraph}
\end{center}
\end{figure}
\mbox{\Hypertarget{classMultiStart_a0ad5ed40a5c4ab964cb27f79343eed98}\label{classMultiStart_a0ad5ed40a5c4ab964cb27f79343eed98}} 
\index{Multi\+Start@{Multi\+Start}!get\+Worst\+Md@{get\+Worst\+Md}}
\index{get\+Worst\+Md@{get\+Worst\+Md}!Multi\+Start@{Multi\+Start}}
\subsubsection{\texorpdfstring{get\+Worst\+Md()}{getWorstMd()}}
{\footnotesize\ttfamily std\+::pair$<$ int, bool $>$ Multi\+Start\+::get\+Worst\+Md (\begin{DoxyParamCaption}\item[{std\+::vector$<$ int $>$}]{solution }\end{DoxyParamCaption})}



Return the worst node (worst afinity) in the actual solution. 

\begin{DoxyReturn}{Returns}
std\+::pair$<$int,bool$>$ 
\end{DoxyReturn}

\begin{DoxyCode}
67 \{
68   std::vector<std::pair<int, bool>> vertexVector;
69   std::pair<int, bool> vertex(-1, \textcolor{keyword}{false});
70   vertexVector.push\_back(vertex);
71   \textcolor{keywordtype}{float} currentDistance = graph.\hyperlink{classMatriz_a8df14a27d791f24206dd633b2a685c5b}{getMd}(solution);
72   \textcolor{keywordtype}{float} currentEdgeSum = currentDistance * solution.size();
73   \textcolor{keywordflow}{for} (\textcolor{keywordtype}{int} i = 0; i < solution.size(); i++)
74   \{
75     \textcolor{keywordtype}{int} vertex = solution[i];
76     solution.erase(solution.begin() + i);
77     \textcolor{keywordtype}{float} nextMd = graph.\hyperlink{classMatriz_a8df14a27d791f24206dd633b2a685c5b}{getMd}(solution);
78     solution.insert(solution.begin() + i, vertex);
79     \textcolor{keywordflow}{if} (nextMd > currentDistance)
80     \{
81       \textcolor{keywordflow}{if} (anxious)
82       \{
83         \textcolor{keywordflow}{return} std::pair<int, bool>(i, \textcolor{keyword}{true});
84         ;
85       \}
86       currentDistance = nextMd;
87       vertexVector.clear();
88       vertexVector.push\_back(std::pair<int, bool>(i, \textcolor{keyword}{true}));
89     \}
90     \textcolor{keywordflow}{else} \textcolor{keywordflow}{if} (nextMd == currentDistance)
91     \{
92       vertexVector.push\_back(std::pair<int, bool>(i, \textcolor{keyword}{true}));
93     \}
94   \}
95   \textcolor{keywordflow}{return} vertexVector[rand() % vertexVector.size()];
96 \}
\end{DoxyCode}
Here is the call graph for this function\+:\nopagebreak
\begin{figure}[H]
\begin{center}
\leavevmode
\includegraphics[width=327pt]{classMultiStart_a0ad5ed40a5c4ab964cb27f79343eed98_cgraph}
\end{center}
\end{figure}
Here is the caller graph for this function\+:\nopagebreak
\begin{figure}[H]
\begin{center}
\leavevmode
\includegraphics[width=350pt]{classMultiStart_a0ad5ed40a5c4ab964cb27f79343eed98_icgraph}
\end{center}
\end{figure}
\mbox{\Hypertarget{classMultiStart_af27ae5dbba5f924070f103b7bf5987a3}\label{classMultiStart_af27ae5dbba5f924070f103b7bf5987a3}} 
\index{Multi\+Start@{Multi\+Start}!local\+Search@{local\+Search}}
\index{local\+Search@{local\+Search}!Multi\+Start@{Multi\+Start}}
\subsubsection{\texorpdfstring{local\+Search()}{localSearch()}}
{\footnotesize\ttfamily std\+::vector$<$ int $>$ Multi\+Start\+::local\+Search (\begin{DoxyParamCaption}\item[{std\+::vector$<$ int $>$}]{solution,  }\item[{std\+::vector$<$ int $>$}]{first\+Candidates }\end{DoxyParamCaption})}



Function that uses a greedy algorithm to improve the solution. 

\begin{DoxyReturn}{Returns}
std\+::vector$<$int$>$ 
\end{DoxyReturn}

\begin{DoxyCode}
51 \{
52   \textcolor{keywordtype}{bool} improvement = \textcolor{keyword}{true};
53   \textcolor{keywordflow}{while} (improvement)
54   \{
55     improvement = \textcolor{keyword}{false};
56     std::pair<int, bool> worst = \hyperlink{classMultiStart_a0ad5ed40a5c4ab964cb27f79343eed98}{getWorstMd}(solution);
57     \textcolor{keywordflow}{if} (worst.second)
58     \{
59       improvement = \textcolor{keyword}{true};
60       solution.erase(solution.begin() + worst.first);
61     \}
62   \}
63   \textcolor{keywordflow}{return} solution;
64 \}
\end{DoxyCode}
Here is the call graph for this function\+:\nopagebreak
\begin{figure}[H]
\begin{center}
\leavevmode
\includegraphics[width=350pt]{classMultiStart_af27ae5dbba5f924070f103b7bf5987a3_cgraph}
\end{center}
\end{figure}
Here is the caller graph for this function\+:\nopagebreak
\begin{figure}[H]
\begin{center}
\leavevmode
\includegraphics[width=350pt]{classMultiStart_af27ae5dbba5f924070f103b7bf5987a3_icgraph}
\end{center}
\end{figure}
\mbox{\Hypertarget{classMultiStart_a456dc441b6e7028aa86a0488830f9bc1}\label{classMultiStart_a456dc441b6e7028aa86a0488830f9bc1}} 
\index{Multi\+Start@{Multi\+Start}!R\+CL@{R\+CL}}
\index{R\+CL@{R\+CL}!Multi\+Start@{Multi\+Start}}
\subsubsection{\texorpdfstring{R\+C\+L()}{RCL()}}
{\footnotesize\ttfamily std\+::vector$<$ int $>$ Multi\+Start\+::\+R\+CL (\begin{DoxyParamCaption}\item[{std\+::vector$<$ int $>$}]{solution,  }\item[{std\+::vector$<$ int $>$}]{first\+Candidates }\end{DoxyParamCaption})}



Function to create a R\+CL array based on an initial solution. 

\begin{DoxyReturn}{Returns}
std\+::vector$<$int$>$ 
\end{DoxyReturn}

\begin{DoxyCode}
21 \{
22   std::vector<int> sortedNodes;
23   std::vector<float> sortedDistances;
24   std::vector<int> rclVector;
25   \textcolor{keywordflow}{for} (\textcolor{keywordtype}{int} i = 0; i < firstCandidates.size(); i++)
26   \{
27     \textcolor{keywordflow}{if} (std::find(solution.begin(), solution.end(), firstCandidates[i]) == solution.end())
28     \{
29       solution.push\_back(firstCandidates[i]);
30       \textcolor{keywordtype}{float} testMd = graph.\hyperlink{classMatriz_a8df14a27d791f24206dd633b2a685c5b}{getMd}(solution);
31       solution.pop\_back();
32       \textcolor{keywordtype}{int} position = 0;
33       \textcolor{keywordflow}{for} (\textcolor{keywordtype}{int} j = 0; j < sortedDistances.size(); j++)
34       \{
35         \textcolor{keywordflow}{if} (testMd < sortedDistances[j])
36         \{
37           position++;
38         \}
39       \}
40       sortedDistances.insert(sortedDistances.begin() + position, testMd);
41       sortedNodes.insert(sortedNodes.begin() + position, firstCandidates[i]);
42     \}
43   \}
44   \textcolor{keywordtype}{int} percent = (sortedNodes.size() / (1 / 0.2));
45   percent = percent == 0 ? 1 : percent;
46   std::copy(sortedNodes.begin(), sortedNodes.begin() + percent, std::back\_inserter(rclVector));
47   \textcolor{keywordflow}{return} rclVector;
48 \}
\end{DoxyCode}
Here is the call graph for this function\+:\nopagebreak
\begin{figure}[H]
\begin{center}
\leavevmode
\includegraphics[width=287pt]{classMultiStart_a456dc441b6e7028aa86a0488830f9bc1_cgraph}
\end{center}
\end{figure}
Here is the caller graph for this function\+:\nopagebreak
\begin{figure}[H]
\begin{center}
\leavevmode
\includegraphics[width=321pt]{classMultiStart_a456dc441b6e7028aa86a0488830f9bc1_icgraph}
\end{center}
\end{figure}


The documentation for this class was generated from the following files\+:\begin{DoxyCompactItemize}
\item 
include/\hyperlink{multiStart_8hpp}{multi\+Start.\+hpp}\item 
src/multi\+Start.\+cpp\end{DoxyCompactItemize}
